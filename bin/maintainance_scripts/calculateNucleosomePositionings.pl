#! /usr/bin/perl -w

#  Copyright (C) 2008 Stefan Lang

#  This program is free software; you can redistribute it
#  and/or modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation;
#  either version 3 of the License, or (at your option) any later version.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.

#  You should have received a copy of the GNU General Public License
#  along with this program; if not, see <http://www.gnu.org/licenses/>.

=head1 calculateNucleosomePositionings.pl

This class is used to store and get nucleosome positioning data. The data can be generated by the scripts descibed in PIMD:19092803. To work with this database::genomeDB the scripts have been wraped by the script calculateNucleosomePositionings.pl.

To get further help use 'calculateNucleosomePositionings.pl -help' at the comman line.

=cut

use Getopt::Long;
use strict;
use warnings;
use File::HomeDir;
use stefans_libs::root;
use stefans_libs::database::genomeDB;
use stefans_libs::database::system_tables::workingTable;
use stefans_libs::database::system_tables::loggingTable;
use stefans_libs::database::system_tables::errorTable;
use stefans_libs::database::genomeDB::nucleosomePositioning;
use Shell qw(ps);

my ( $help, $debug, $organism, $executable, $nucleosomePositioning, $splitValue,
	$cleanUP, $killall );

Getopt::Long::GetOptions(
	"-organism=s"       => \$organism,
	"-executable=s"     => \$executable,
	"-max_seq_length=s" => \$splitValue,
	"-clean_up=s"       => \$cleanUP,
	"-killall"          => \$killall,
	"-help"             => \$help,
	"-debug"            => \$debug
);

if ($help) {
	print helpString();
	exit;
}

if ( defined $cleanUP ) {
	## Ups - we need to clean up behind an old instance....
	&remove_ThreadProblem($cleanUP);
	exit;
}

unless ( defined $organism ) {
	print helpString(
"we definitly need to know which organism to use to get the sequence files!"
	);
	exit;
}
unless ( defined $executable || -f $executable ) {
	print helpString(
"we definitly need to know the position of the local installation of the search script described in PID:19092803!"
	);
	exit;
}

my $homeDir = File::HomeDir->home();


if ( $killall ) {
	warn "now we kill all types of downstream processes. The most prominent and problematic at least...\n";
	system ( "killall map_learn_static");
	system ( "killall gxw2stats.pl");
	system ( "killall nucleosome_prediction.pl");
	system ( "killall body.pl");
	system ( "killall cut.pl");
	system ( "rm $homeDir/*temporary_seq.fa ");
	system ( "rm $homeDir/tmp_*");
	exit;
}

$homeDir .= "/temp";

my (
	$database,     $gbFile,  $temp_gbFile,  $executablePath,
	@array,        $dataset, $workingTable, $stop,
	$loggingTable, $work, $errorTable, $we_have_work_to_do
);

$database = genomeDB->new()->GetDatabaseInterface_for_Organism($organism);

unless ( ref($database) eq "chromosomesTable" ) {
	warn "\nSorry, but there is no genome database for organism $organism\n";
	exit;
}
@array = split( "/", $executable );
pop @array;
$executablePath = join( "/", @array );

$temp_gbFile .= "$$-temporaray_seq.fa";

$nucleosomePositioning = $database->getNucleosomePositioning_Table();
$splitValue            = 10000000
  unless ( defined $splitValue
	|| $splitValue > $nucleosomePositioning->{dataLength} * 2 );

$workingTable = workingTable->new();
$loggingTable = loggingTable->new();

my $gbFile_identiNr = 0;
$errorTable = errorTable->new();
$we_have_work_to_do = 1;

while ( $we_have_work_to_do ) {
	$gbFile_identiNr ++;
	$workingTable->set_workload(
		{
			'PID'       => $$,
			'programID' => 'calculateNucleosomePositionings',
			'description' =>
			  "organism $organism gbFileID $gbFile_identiNr"
		}
	);
	## we need to check, if that file is already evaluated!
	$dataset = $workingTable->select_workloads_for_program(
		"calculateNucleosomePositionings");
	$stop = 0;
	foreach my $entry (@$dataset) {

		#print "we get the description '$entry->{'description'}'\n";
		if ( $entry->{'description'} eq
			"organism $organism gbFileID $gbFile_identiNr"  && !  ($entry->{'PID'} == $$) )
		{
			warn
"The process $entry->{PID} is evaluating the gbFile $gbFile_identiNr at the moment\n",
			  "I will continue witzh the next one!\n";
			$stop = 1;
			$workingTable->delete_workload_for_PID($$);
		}

	}
	next if ($stop);
	
	if (
		$nucleosomePositioning->DataExists(
			$database->{'tableBaseName'},
			$gbFile_identiNr
		)
	  )
	{
		$workingTable->delete_workload_for_PID($$);
		warn
"PID $$: The gbFile with the ID $gbFile_identiNr has already been evaluated! -> next gbFile ;-)\n";
		next;

	}
	$gbFile = $database -> get_gbFile_for_gbFile_id ( undef, $gbFile_identiNr );
	unless ( defined $gbFile){
		## we are ready! - we can end this evaluation by removing our entry from the workload table and exiting.
		## in this way, the perl_demon can see that we do not need to be restarted!
		$we_have_work_to_do = 0;
		$workingTable->delete_workload_for_PID($$);
		next;
	}
	warn "not a gbFile object ( $gbFile ) " unless ( ref($gbFile) eq "gbFile" );
	
	## if the data is too large ( more than 10 mega bases long) it may be usefull to chop it to smaller pieces.
	## I would prefere a region of about 10Mb...
	## but we get certain unwanted effects at the borders - therefore we have to create a
	## 2 * $nucleosomePositioning->{dataLength} bp overlap at the end of the regions.
	## Only one $nucleosomePositioning->{dataLength} is inserted in the actual round.
	## Upon the next round the first $nucleosomePositioning->{dataLength} is discarded.
	## And here comes the need of functions....
	## -> calculate nucleosome positions for region of gbFile (start, end)
	## -> insert nucleosome positions for region ( offset, start, $discard_last)

	## for ( my $i =0;  $i < $gbFile -> Length(); $i += 10000000 )
	## calculate the positions for gbFile string $i to $i + 10000000 + 2 * $nucleosomePositioning->{dataLength}
	## if $gbFile -> Length() < $i + 10000000 + 2 * $nucleosomePositioning->{dataLength}
	##		if $i != 0 -> insert the positions as normal from start to end
	##		else insert the positions and add a offset of $nucleosomePositioning->{dataLength}
	## else
	##    	if $i == 0 -> insert the positions as normal from start, but add the $discard_last flag
	##  	else insert the positions with a offset of $nucleosomePositioning->{dataLength} and the $discard_last flag

	for ( my $i = 0 ; $i < $gbFile->Length() ; $i += $splitValue ) {
		if ( $gbFile-> Get_SubSeq ($i,$i + $splitValue + 2 * $nucleosomePositioning->{dataLength} ) =~ m/N/ ){
			warn "there are 'N' nucleotides in gbFile $gbFile_identiNr between $i and ",($i + $splitValue + 2 * $nucleosomePositioning->{dataLength}), " bp\n";
			$errorTable->set_error_log ( {'PID'       => $$,
			'programID' => 'calculateNucleosomePositionings',
			'description' =>
			  "organism $organism gbFileID $gbFile_identiNr start = $i; end = ".($i + $splitValue + 2 * $nucleosomePositioning->{dataLength}).": we have N nucleotides - no calculation possible!" } );
			 if ( $i == 0){
			 	## shit - if we do not block it here we will not be able to use another process, as we will always die here!
			 	open (FAKE_DATA ,">$homeDir/$temp_gbFile.txt" );
			 	print FAKE_DATA 
				"Sequence        Position        P start P occupied\n",
				"TEMP    0       n.a	n.a\n",
				"TEMP    1       n.a	n.a\n";
				close ( FAKE_DATA );
			 	
			 	$dataset = {
					'baseName' => $database->{'tableBaseName'},
					'gbFile_id'     => $gbFile_identiNr,
					'datafile' => "$homeDir/$temp_gbFile.txt",
					'start'    => $i + 1
				};
			 	$nucleosomePositioning->readInDataFile($dataset);
			 	system ( "rm $homeDir/$temp_gbFile.txt");
			 }
			 next;
		}
		$gbFile->WriteAsFasta( $temp_gbFile, "temp", $i,
			$i + $splitValue + 2 * $nucleosomePositioning->{dataLength} );
		## this process will silently die if we have N nucleotides in the Sequence. But that is perhaps the best thing we can do or?
		## the sequences that do have N nucleotides in them tend to be not really reliable??
		## We won't change that!
		
		system(
"$executable -t test -tab $temp_gbFile.txt $executablePath/model/nucleosome_model_1208.gxw -s $temp_gbFile > $homeDir/$temp_gbFile.txt"
		);
		unless ( -f "$homeDir/$temp_gbFile.txt" ) {
			warn "OOPS no informations could be calculated for gbFile ",
			  $gbFile->Version(), "\n";
			exit if ($debug);
			next;
		}
		system("rm $temp_gbFile");

		## now read the results and push it into a database...

		print
"executable calculateNucleosomePositionings: we are evaluating gbFile_id  $gbFile_identiNr starting at bp position $i\n";

		$dataset = {
			'baseName' => $database->{'tableBaseName'},
			'gbFile_id'     => $gbFile_identiNr,
			'datafile' => "$homeDir/$temp_gbFile.txt",
			'start'    => $i + 1
		};

		if (   $i > 0
			&& $i + 2 * $nucleosomePositioning->{dataLength} <
			$gbFile->Length() )
		{
			warn "\nwe will now add the keys 'start' => ", $dataset->{start},
			  " and 'skipp_first' =>",
			  $nucleosomePositioning->{dataLength},
			  " before we run the insert!\n"
			  if ($debug);
			$dataset->{skipp_first} = $nucleosomePositioning->{dataLength} + 1;
		}
		if ( $i + $splitValue + 2 * $nucleosomePositioning->{dataLength} <
			$gbFile->Length() )
		{
			$dataset->{skipp_last} =
			  $splitValue + $nucleosomePositioning->{dataLength};
			warn "we added key 'skipp_last' => $dataset->{skipp_last}\n\n"
			  if ($debug);
		}

		$nucleosomePositioning->readInDataFile($dataset);
		system("rm $homeDir/$temp_gbFile.txt");
		$work = $workingTable->select_workloads_for_PID($$);
		$loggingTable->set_log(
			{
				'programID' => 'calculateNucleosomePositionings',
				'description' =>
				  "PID $$ organism $organism gbFileID $gbFile_identiNr from $i bp to ".($i + $splitValue + 2 * $nucleosomePositioning->{dataLength})." bp",
				'start_time' => @$work[0]->{'timeStamp'}
			}
		);
	}
	$gbFile = undef;
	
	$workingTable->delete_workload_for_PID($$);

}

print "we have finished the job!\n";
## now we need to remove our own entry from the DB.

sub helpString {
	my $errorMessage = shift;
	$errorMessage = ' ' unless ( defined $errorMessage );
	return "
 $errorMessage
 command line switches for calculateNucleosomePositionings.pl

   -organism       :the organism string that is used for the database::genomeDB database to get the sequence files 
   -executable     :the position of the script to identify possible nucleosme positioning informations. 
                    The script is described in PMID:19092803.
   -max_seq_length :the maximum sequence length a gbFile may have to be evaluated 
                    (otherwise it will be split into smaller parts; default = 10^7)
   -killall        :clear up all downstream processes!
   -clear_up       :clear up everything from the database
   -help           :print this help
   -debug          :verbose output


";
}

sub remove_ThreadProblem {
	my ($defective_PID) = @_;
	my $workingTable = workingTable->new();
	my ( $defectiveWorkload, $workloads );
	$defectiveWorkload =
	  $workingTable->select_workloads_for_PID($defective_PID);
	## an array ref to hashes containing the values 'PID', 'programID', 'timeStamp' and 'description'.
# 1. the PID is not working anymore
# 2. the file the PID was working on might have bad values stored.
# 3. perhaps we got a conflict and everything is OK with the overall process, but we nevertheless have to remove the entry.
# 4. the description entry in the db looks like that: 'organism $organism gbFileID $database->{'_lastPosition'}'
    system ( "rm $$-temporaray_seq.fa $$-temporaray_seq.fa.txt");
	$workloads =
	  $workingTable->select_workloads_for_description(
		@$defectiveWorkload[0]->{'description'} );
	unless ( defined @$workloads[0] ) {
		## we do not have another variable working here!
		## This may be a really heavy error - we should better quit with a nice error message!
		$workingTable->delete_workload_for_PID($defective_PID);
		die
"calculateNucleosomePositioning:remove_ThreadProblem -> we could not solve the problem!\n";
	}
	else {
		## we got a simple race situation - not that evil - just remove the old values and restart
		$workingTable->delete_workload_for_PID($defective_PID);
	}
	return 1;
}
